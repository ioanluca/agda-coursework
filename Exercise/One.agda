{-# OPTIONS --allow-unsolved-metas #-}
module Exercise.One where

open import Lib.Basics
open import Lib.Nat

------------------------------------------------------------------------------
-- ORDER-PRESERVING EMBEDDINGS (or "thinnings" for short)
------------------------------------------------------------------------------

-- The type xs <: ys represents the possible order-preserving
-- embeddings from xs to ys. That means ys is generated by
-- inserting more stuff anywhere in xs, i.e. "thinning" xs.

data _<:_ {X : Set} : List X -> List X -> Set where
  o' : forall {x ys zs} -> ys <: zs ->       ys  <:  x ,- zs  -- insert new
  os : forall {x ys zs} -> ys <: zs ->  x ,- ys  <:  x ,- zs  -- keep old
  oz :                                    []     <:    []     -- done!

infix 50 _<:_

-- You can also think of xs <: ys as the ways of selecting
-- elements xs from ys, with
--   o' meaning "drop the head",
--   os meaning "take the head",
--   oz meaning "end of list".

-- You can also see a thinning in xs <: ys as a vector of bits
-- telling whether each element position in ys is connected
-- from an element position in xs.

--              2 ,-      4 ,- []
--    o'  (o'  (os  (o'  (os   oz))))
--    0 ,- 1 ,- 2 ,- 3 ,- 4 ,- []


------------------------------------------------------------------------------
-- Exploration (for comprehension rather than credit)
------------------------------------------------------------------------------

-- Lists of elements of One are a lot like numbers

num : Nat -> List One
num zero    = []
num (suc n) = <> ,- num n

-- Using C-c C-a with -l and -s options, generate exhaustive lists of
-- thinnings with the following types.

pick0from4 : List (num 0 <: num 4)
pick0from4 = o' (o' (o' (o' oz))) ,- []

pick1from4 : List (num 1 <: num 4)
pick1from4 = o' (o' (os (o' oz))) ,- o' (os (o' (o' oz))) ,- os (o' (o' (o' oz))) ,- o' (o' (o' (os oz))) ,- []

pick2from4 : List (num 2 <: num 4)
pick2from4 = o' (o' (os (os oz))) ,- o' (os (o' (os oz))) ,- o' (os (os (o' oz))) ,- os (o' (o' (os oz))) ,- os (o' (os (o' oz))) ,- os (os (o' (o' oz))) ,- []

pick3from4 : List (num 3 <: num 4)
pick3from4 = o' (os (os (os oz))) ,- os (o' (os (os oz))) ,- os (os (o' (os oz))) ,- os (os (o' (os oz))) ,- []
          
pick4from4 : List (num 4 <: num 4)
pick4from4 = os (os (os (os oz))) ,- []
-- But with more interesting elements, we have fewer options, sometimes.

thinOdds : List (1 ,- 3 ,- 5 ,- [] <: 0 ,- 1 ,- 2 ,- 3 ,- 4 ,- 5 ,- 6 ,- [])
thinOdds = o' (os (o' (os (o' (os (o' oz)))))) ,- []


------------------------------------------------------------------------------
-- 1.1 Categorical Structure
------------------------------------------------------------------------------

-- Construct the identity thinning from any list to itself.

oi : forall {X}{xs : List X} -> xs <: xs
oi {xs = []} = oz
oi {xs = x ,- xs} = os oi

-- Give composition for thinnings. Minimize the number of cases.

_-<-_ : forall {X}{xs ys zs : List X} -> xs <: ys -> ys <: zs -> xs <: zs
th -<- o' ph = o' (th -<- ph)
o' th -<- os ph = o' (th -<- ph)
os th -<- os ph = os (th -<- ph)
oz -<- oz = oz

infixl 40 _-<-_

-- Prove the following laws. Minimize the number of cases (which will
-- depend on your definition of _-<-_).

oi-<- : forall {X}{xs ys : List X}(ph : xs <: ys) -> oi -<- ph == ph
oi-<- (o' ph) with (oi -<- ph) | (oi-<- ph)
oi-<- (o' {x} ph) | .ph | refl = refl
oi-<- (os ph) = os $= oi-<- ph
oi-<- oz = refl

_-<-oi : forall {X}{xs ys : List X}(th : xs <: ys) -> th -<- oi == th
o' th -<-oi = o' $= (th -<-oi)
os th -<-oi = os $= (th -<-oi)
oz -<-oi = refl

assoc-<- : forall {X}{ws xs ys zs : List X}
             (th0 : ws <: xs)(th1 : xs <: ys)(th2 : ys <: zs) ->
             (th0 -<- th1) -<- th2 == th0 -<- (th1 -<- th2)
assoc-<- th0 th1 (o' th2) = o' $= assoc-<- th0 th1 th2
assoc-<- th0 (o' th1) (os th2) = o' $= assoc-<- th0 th1 th2
assoc-<- (o' th0) (os th1) (os th2) = o' $= assoc-<- th0 th1 th2
assoc-<- (os th0) (os th1) (os th2) = os $= assoc-<- th0 th1 th2
assoc-<- oz oz oz = refl


------------------------------------------------------------------------------
-- 1.2 Emptiness
------------------------------------------------------------------------------

-- Show that the empty list embeds into all lists in a unique way.
 
oe : forall {X}{xs : List X} -> [] <: xs
oe {xs = []} = oz
oe {xs = x ,- xs} = o' oe

oe-unique : forall {X}{xs : List X}(th : [] <: xs) -> th == oe
oe-unique {xs = []} oz = refl
oe-unique {xs = x ,- xs} (o' th) = o' $= oe-unique {xs = xs} th


------------------------------------------------------------------------------
-- 1.3 Antisymmetry
------------------------------------------------------------------------------

-- Show that if two lists are mutually embeddable, they are equal
-- and the embeddings are the identity.

antisym : forall {X}{xs ys : List X}
             (th : xs <: ys)(ph : ys <: xs) ->
             Sg (xs == ys) \
             { refl -> th == oi * ph == oi }
antisym (o' th) ph with antisym th (o' oi -<- ph) 
antisym (o' .(os oi)) (o' ph) | refl , refl , ()
antisym (o' .(os oi)) (os ph) | refl , refl , () 
antisym (os th) (o' ph) with antisym th (o' oi -<- ph)
antisym (os .(os oi)) (o' (o' ph)) | refl , refl , ()
antisym (os .(os oi)) (o' (os ph)) | refl , refl , ()
antisym (os th) (os ph) with antisym th ph
antisym (os .oi) (os .oi) | refl , refl , refl = refl , refl , refl 
antisym oz oz = refl , refl , refl 

-- Deduce that oi is unique.

oi-unique : forall {X}{xs : List X}(th : xs <: xs) -> th == oi
oi-unique th with antisym th th
oi-unique th | refl , fst , snd = fst 



------------------------------------------------------------------------------
-- 1.4 Thinnings as selections
------------------------------------------------------------------------------

-- We can use the "selection" interpretation of thinnings to act
-- on data indexed by lists.
-- The type All P ys has elements of type P y for each y in ys.
-- If xs <: ys, show that we can get P x for each x in xs.

select : forall {X}{xs ys : List X}{P : X -> Set} ->
         xs <: ys -> All P ys -> All P xs
select oz [] = []
select (o' th) (py ,- pys) = select th pys
select (os th) (py ,- pys) = py ,- select th pys  

-- Now prove the following laws relating to selecting by the
-- identity and composition.

select-oi : forall {X}{xs : List X}{P : X -> Set} -> (pxs : All P xs) ->
            select oi pxs == pxs
select-oi [] = refl 
select-oi (px ,- pxs) rewrite select-oi pxs = refl 

select-<- : forall {X}{xs ys zs : List X}{P : X -> Set} ->
            (th : xs <: ys)(ph : ys <: zs) -> (pzs : All P zs) ->
            select (th -<- ph) pzs == select th (select ph pzs)
select-<- th (o' ph) (pz ,- pzs) = select-<- th ph pzs
select-<- (o' th) (os ph) (pz ,- pzs) = select-<- th ph pzs
select-<- (os th) (os ph) (pz ,- pzs) rewrite select-<- th ph pzs = refl
select-<- oz oz [] = refl 


------------------------------------------------------------------------------
-- 1.5 Splittings
------------------------------------------------------------------------------

-- If we have two thinnings,
--   th : xs <: zs
--   ph : ys <: zs
-- we can say what it means for th and ph to *split* zs:
-- every element position in zs is connected from either
-- a position in xs or from a position in ys, but *not both*.

data Splitting {X : Set} : {xs ys zs : List X}
                           (th : xs <: zs)(ph : ys <: zs) 
                           -> Set where
  split's : forall {w xs ys zs}{th : xs <: zs}{ph : ys <: zs} ->
             Splitting th ph ->
             Splitting {zs = w ,- _} (o' th) (os ph)
  splits' : forall {w xs ys zs}{th : xs <: zs}{ph : ys <: zs} ->
             Splitting th ph ->
             Splitting {zs = w ,- _} (os th) (o' ph)
  splitzz : Splitting oz oz

-- Show that if we know how xs <: zs, we can find a splitting of zs by
-- computing...

thinSplit : {X : Set}{xs zs : List X}(th : xs <: zs) ->
            Sg (List X) \ ys ->    -- ...what wasn't from xs...
            Sg (ys <: zs) \ ph ->  -- ...but was in zs...
            Splitting th ph        -- ...hence forms a splitting.
thinSplit (o' th) with thinSplit th
thinSplit {zs = z ,- zs} (o' th) | ys , ph , sp = z ,- ys , os ph , split's sp
thinSplit  (os th) with thinSplit th
thinSplit  (os th) | ys , ph , sp = ys , o' ph , splits' sp
thinSplit oz = [] , oz , splitzz


-- Given a splitting, show that we can "riffle" together a bunch
-- of "All P"-s for each selection to get an "All P" for the whole.

riffle : forall {X : Set}{xs ys zs : List X}
                {th : xs <: zs}{ph : ys <: zs}
                {P : X -> Set} ->
                All P xs -> Splitting th ph -> All P ys ->
                All P zs
riffle pxs (split's s) (py ,- pys) = py ,- riffle pxs s pys
riffle (px ,- pxs) (splits' s) pys = px ,- riffle pxs s pys
riffle pxs splitzz pys = [] 

-- Moreover, we can use a splitting to invert "riffle", dealing
-- out an "All P" for the whole list into the parts for each
-- selection in the splitting, and making sure that the parts
-- riffle back together to make the whole.

data Deal {X : Set}{xs ys zs : List X}
          {th : xs <: zs}{ph : ys <: zs}(s : Splitting th ph)
          {P : X -> Set} :
            All P zs -> Set where
  dealt : (pxs : All P xs)(pys : All P ys) -> Deal s (riffle pxs s pys)

deal : {X : Set}{xs ys zs : List X}
       {th : xs <: zs}{ph : ys <: zs}(s : Splitting th ph)
       {P : X -> Set}(pzs : All P zs) -> Deal s pzs
deal splitzz [] = dealt [] []
deal (split's s) (pz ,- pzs) with deal s pzs
deal (split's s) (pz ,- .(riffle pxs s pys)) | dealt pxs pys = dealt pxs (pz ,- pys ) 
deal (splits' s) (pz ,- pzs) with deal s pzs
deal (splits' s) (pz ,- .(riffle pxs s pys)) | dealt pxs pys = dealt (pz ,- pxs) pys 


------------------------------------------------------------------------------
-- 1.6 Composability as a relation
------------------------------------------------------------------------------

-- We have the composition *operator*, but it is sometimes more
-- convenient to work with the *call graph* of the composition operator,
-- giving the explanations for why an output comes from some input.

-- For example, the call graph of our boolean <= operator from Lecture.One
_<=b_ : Nat -> Nat -> Two
zero <=b y = tt
suc x <=b zero = ff
suc x <=b suc y = x <=b y

-- would be
data Graph<= : Nat -> Nat -> Two -> Set where
   le-z-y : forall {y} -> Graph<= zero    y    tt
   le-s-z : forall {x} -> Graph<= (suc x) zero ff
   le-s-s : forall {x y b} -> Graph<= x y b -> Graph<= (suc x) (suc y) b

-- so that we can always show 
graph<=b : (x y : Nat) -> Graph<= x y (x <=b y)
graph<=b zero y = le-z-y
graph<=b (suc x) zero = le-s-z
graph<=b (suc x) (suc y) = le-s-s (graph<=b x y)

-- nice :d

-- Define the inductive composability relation on three thinnings.
-- This should correspond to your composition function, with one
-- constructor per line of your function, and one recursive substructure
-- per recursive call. We've written the type declaration, but you need
-- to add the constructors.

-- No defined function symbols should appear in any of the type indices,
-- just variables and constructors. That means dependent pattern matching
-- will play nice.

-- _-<-_ : forall {X}{xs ys zs : List X} -> xs <: ys -> ys <: zs -> xs <: zs
-- th -<- o' ph = o' (th -<- ph)
-- o' th -<- os ph = o' (th -<- ph)
-- os th -<- os ph = os (th -<- ph)
-- oz -<- oz = oz

data Composable-<- {X : Set}
     : {xs ys zs : List X}
       (th : xs <: ys)(ph : ys <: zs)(thph : xs <: zs)
       -> Set where
  -- your constructors here!
     co-th-o'ph : {z : X}{xs ys zs : List X}(th : xs <: ys)(ph : ys <: zs)(thph : xs <: zs)
      -> Composable-<- th ph thph -> Composable-<- {zs = z ,- zs} th (o' ph) (o' thph)
     co-o'th-osph : {y : X}{xs ys zs : List X}(th : xs <: ys)(ph : ys <: zs)(thph : xs <: zs)
      -> Composable-<- th ph thph -> Composable-<- {ys = y ,- ys} (o' th) (os ph) (o' thph)
     co-osth-osph : {x : X}{xs ys zs : List X}(th : xs <: ys)(ph : ys <: zs)(thph : xs <: zs)
      -> Composable-<- th ph thph -> Composable-<- {xs = x ,- xs} (os th) (os ph) (os thph)
     co-oz-oz : Composable-<- oz oz oz

-- Show that your definition really captures composability by
-- proving the following.

composable-<- : forall {X : Set}{xs ys zs : List X}
                (th : xs <: ys)(ph : ys <: zs) ->
                Composable-<- th ph (th -<- ph)
  -- i.e., we have *at least* composition...
composable-<- th (o' ph) = co-th-o'ph th ph (th -<- ph) (composable-<- th ph)
composable-<- (o' th) (os ph) = co-o'th-osph th ph (th -<- ph) (composable-<- th ph)
composable-<- (os th) (os ph) = co-osth-osph th ph (th -<- ph) (composable-<- th ph)
composable-<- oz oz = co-oz-oz

composable-unique : forall {X : Set}{xs ys zs : List X}
                    {th : xs <: ys}{ph : ys <: zs}
                    {thph thph' : xs <: zs} ->
                    Composable-<- th ph thph ->
                    Composable-<- th ph thph' ->
                    thph == thph'
  -- ...and nothing but composition.
composable-unique (co-th-o'ph .th .ph thph₁ c) (co-th-o'ph th ph thph d) =
   o' $= composable-unique c d
composable-unique (co-o'th-osph .th .ph thph₁ c) (co-o'th-osph th ph thph d) =
   o' $= composable-unique c d
composable-unique (co-osth-osph .th .ph thph₁ c) (co-osth-osph th ph thph d) =
   os $= composable-unique c d 
composable-unique co-oz-oz co-oz-oz = refl

-- Your prize for establishing the graph representation is to have a nice time
-- showing that thinnings really are *embeddings* (or "monomorphisms").
-- If you have two thinnings, th and th' that compose with some ph to get
-- equal results, th and th' must have been equal in the first place. That
-- tells you something important about ph, namely that it maps all its source
-- positions to distinct target positions.

composable-mono : forall {X}{xs ys zs : List X}
  {th th' : xs <: ys}{ph : ys <: zs}{ps : xs <: zs} ->
  Composable-<- th ph ps -> Composable-<- th' ph ps ->
  th == th'
composable-mono (co-th-o'ph th₁ .ph .thph c) (co-th-o'ph th ph thph d) = composable-mono c d
composable-mono (co-o'th-osph th₁ .ph .thph c) (co-o'th-osph th ph thph d) =
                 o' $= composable-mono c d
composable-mono (co-osth-osph th₁ .ph .thph c) (co-osth-osph th ph thph d) =
                 os $= composable-mono c d
composable-mono co-oz-oz co-oz-oz = refl

-- Now use composable-<- and composable-mono to get a cheap proof of the
-- following.

mono-<- : forall {X}{xs ys zs : List X}(th th' : xs <: ys)(ph : ys <: zs) ->
             th -<- ph == th' -<- ph ->
             th == th'
mono-<- th th' ph q with composable-<- th ph | composable-<- th' ph
...| c1 | c2 with th -<- ph | q
mono-<- th th' ph q | c1 | c2 | _ | refl = composable-mono c1 c2 


------------------------------------------------------------------------------
-- 1.7 Pullbacks (pointwise "and")
------------------------------------------------------------------------------

-- If we have a situation like this

--
--                ys
--                |
--                | ph
--                v
--     xs ------> zs
--           th

-- we say a "BackSquare" extends the situation to a square

--         side1
-- corner ------> ys
--      |         |
-- side0|         | ph
--      v         v
--     xs ------> zs
--           th

-- where the *same* diagonal is both side0 -<- th and side1 -<- ph,
-- so either path around the square gives the same thinning.

record BackSquare {X}{xs ys zs : List X}
              (th : xs <: zs)(ph : ys <: zs) : Set where
  constructor backSquare
  field
    {corner}   : List X
    {side0}    : corner <: xs
    {side1}    : corner <: ys
    {diagonal} : corner <: zs
    triangle0  : Composable-<- side0 th diagonal
    triangle1  : Composable-<- side1 ph diagonal

open BackSquare

-- The corner of the "best" BackSquare is called a *pullback*,
-- (and the square is called a "pullback square"). What's best
-- about it is that the corner of every other BackSquare embeds
-- in it. That is, it has all the things that both th and ph
-- select from zs.

-- First, construct the pullback square.

pullback-<- : forall {X}{xs ys zs : List X} ->
              (th : xs <: zs)(ph : ys <: zs) ->
              BackSquare th ph
pullback-<- (o' th) (o' ph) with pullback-<- th ph
pullback-<- (o' th) (o' ph) | backSquare t0 t1 =
       backSquare (co-th-o'ph _ _ _ t0) (co-th-o'ph _ _ _ t1) 
pullback-<- (o' th) (os ph) with pullback-<- th ph
pullback-<- (o' th) (os ph) | backSquare t0 t1 =
       backSquare (co-th-o'ph _ _ _ t0) (co-o'th-osph _ _ _ t1) 
pullback-<- (os th) (o' ph) with pullback-<- th ph
pullback-<- (os th) (o' ph) | backSquare t0 t1 =
       backSquare (co-o'th-osph _ _ _ t0) (co-th-o'ph _ _ _ t1)
pullback-<- (os th) (os ph) with pullback-<- th ph
pullback-<- (os th) (os ph) | backSquare t0 t1 =
       backSquare (co-o'th-osph _ _ _ t0) (co-o'th-osph _ _ _ t1)
pullback-<- oz oz = backSquare co-oz-oz co-oz-oz 

-- Then show that every other BackSquare has a corner
-- which embeds in the pullback, and that the resulting
-- triangles commute.

pullback-best : forall {X}{xs ys zs : List X} ->
                {th : xs <: zs}{ph : ys <: zs} ->
                let bs = pullback-<- th ph in
                (bs' : BackSquare th ph) ->
                Sg (corner bs' <: corner bs) \ ps ->
                Composable-<- ps (side0 bs) (side0 bs') *
                Composable-<- ps (side1 bs) (side1 bs')
pullback-best (backSquare (co-th-o'ph th ph thph t0) (co-th-o'ph th₁ ph₁ .thph t1)) = pullback-best (backSquare t0 t1)
pullback-best (backSquare (co-th-o'ph th ph thph t0) (co-o'th-osph th₁ ph₁ .thph t1)) with pullback-best (backSquare t0 t1)
pullback-best (backSquare (co-th-o'ph th ph thph t0) (co-o'th-osph th₁ ph₁ .thph t1)) | ps , h1 , h2 = ps , h1 , co-th-o'ph ps _ _ h2
pullback-best (backSquare (co-o'th-osph th ph thph t0) (co-th-o'ph th₁ ph₁ .thph t1)) with pullback-best (backSquare t0 t1)
pullback-best (backSquare (co-o'th-osph th ph thph t0) (co-th-o'ph th₁ ph₁ .thph t1)) | ps , h1 , h2 = ps , co-th-o'ph ps _ _ h1 , h2
pullback-best (backSquare (co-o'th-osph th ph thph t0) (co-o'th-osph th₁ ph₁ .thph t1)) with pullback-best (backSquare t0 t1)
pullback-best (backSquare (co-o'th-osph th ph thph t0) (co-o'th-osph th₁ ph₁ .thph t1)) | ps , h1 , h2 = ps , co-th-o'ph ps _ _ h1 , co-th-o'ph ps _ _ h2
pullback-best (backSquare (co-osth-osph th ph thph t0) (co-osth-osph th₁ ph₁ .thph t1)) with pullback-best (backSquare t0 t1)
pullback-best (backSquare (co-osth-osph th ph thph t0) (co-osth-osph th₁ ph₁ .thph t1)) | ps , h1 , h2 = {!ps!} , {!!} , {!!}
pullback-best (backSquare co-oz-oz co-oz-oz) = oz , co-oz-oz , co-oz-oz 
